/*
 * INSCRIPTION Externe V1 [EXTERNE]
 * Liste l'ensemble des services et des opérations Ins (Module Inscription) marquées comme [EXTERNE].  Ils peuvent être utilisés par des outils externes à Pegase.  ### Authentification/autorisation obligatoire  Pour tout appel à une opération vous devez être authentifié/authorisé à l'aide d'un [token jwt](https://jwt.io/). Pour cela, chaque requête HTTP doit contenir un token valide dans le header HTTP `Authorization`.  Le format est `Authorization: Bearer <token-jwt>`. Par exemple `Authorization: Bearer xxxx.yyyy.zzzz`.  Lien vers la documentation qui décrit l'authentification aux APIs de Pegase : [pdf](https://share.pc-scol.fr/f/4487c726ade84022ae16/?dl=1)  ### Type de données  Sauf indications spécifiques données au niveau de l'opération, les types de données utilisés dans cette API sont les suivants :   * string - Chaîne de caractères encodée en UTF8 (ex : `Une chaîne de caractère`)     * Dans le cas des descripteurs de type `codeXxx`, seuls les caractères de A à Z, de 0 à 9 et le tiret(-) sont autorisés     * Dans le cas des descripteurs de type montant ou nombre avec une partie décimale, seuls les caractères de 0 à 9 et le point(.) sont autorisés (ex : `12525.99`)   * string($date) - Une date sous la forme d'une chaîne de caractères (ex : `2020-02-25`, norme [ISO-8601](https://fr.wikipedia.org/wiki/ISO_8601))   * string($date-time) - Une date et heure avec fuseau horaire sous la forme d'une chaîne de caractères (ex : `2020-02-25T18:36:22+02:00`, norme [ISO-8601](https://fr.wikipedia.org/wiki/ISO_8601))   * integer($int64) - Un entier sur 64 bits (de -9 223 372 036 854 775 808 à 9 223 372 036 854 775 807) (ex : `2542`)   * integer($int32) - Un entier sur 32 bits (de –2 147 483 648 à 2 147 483 647) (ex : `2542`)   * boolean - Un booléen représenté par `true` ou `false`  ### Code retour  * 200 - Ok : L'opération s'est déroulée avec succès * 201 - Created : L'opération a aboutie à la création d'une ressource * 400 - Bad request :   * Un ou des paramètres d'entrées sont erronées   * Une erreur fonctionnelle s'est produite * 401 - Unauthorized - Vous n'êtes pas authentifié   * Il n'y a pas de token passé dans le header HTTP `Authorization`   * Le token passé n'est pas au bon format (Bearer <[token-jwt](https://jwt.io/)>) * 403 - Forbidden - Vous êtes authentifié mais pas autorisé à exécuter cette opération   * La signature du token est incorrecte / n'a pas pû être vérifiée   * Le token est expiré   * Les habilitations de l'utilisateur ne permettent pas d'exécuter cette opération. Vérifier les droits de l'utilisateur * 404 - Not Found : La ressource demandée n'est pas trouvé     * Remarque : Dans le cas des opérations retournant une liste, on recevra un code 200 avec en résultat une liste vide * 500 - Internal server error : Erreur inattendue et non gérés 
 *
 * The version of the OpenAPI document: 1.3.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.esupportail.referentiel.pcscol.api;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;
import java.util.function.Consumer;

import org.esupportail.referentiel.pcscol.ins.model.ApprenantEtInscriptions;
import org.esupportail.referentiel.pcscol.ins.model.VueInscriptions;
import org.esupportail.referentiel.pcscol.invoker.ApiClient;
import org.esupportail.referentiel.pcscol.invoker.ApiException;
import org.esupportail.referentiel.pcscol.invoker.ApiResponse;
import org.esupportail.referentiel.pcscol.invoker.Configuration;
import org.esupportail.referentiel.pcscol.invoker.Pair;
import org.esupportail.referentiel.pcscol.odf.model.Pageable;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-03T14:58:20.840329264+02:00[Europe/Paris]", comments = "Generator version: 7.12.0")
public class InscriptionsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public InscriptionsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public InscriptionsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Contenu de la pièce
   * Contenu de la pièce
   * @param codeStructure Le code de l&#39;établissement (required)
   * @param codeApprenant Le code apprenant (required)
   * @param codeCible Le code cible avec la période (required)
   * @param codePiece Le code de la demande de pièce (required)
   * @return File
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public File contenuPiece(String codeStructure, String codeApprenant, String codeCible, String codePiece) throws ApiException {
    ApiResponse<File> localVarResponse = contenuPieceWithHttpInfo(codeStructure, codeApprenant, codeCible, codePiece);
    return localVarResponse.getData();
  }

  /**
   * Contenu de la pièce
   * Contenu de la pièce
   * @param codeStructure Le code de l&#39;établissement (required)
   * @param codeApprenant Le code apprenant (required)
   * @param codeCible Le code cible avec la période (required)
   * @param codePiece Le code de la demande de pièce (required)
   * @return ApiResponse&lt;File&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public ApiResponse<File> contenuPieceWithHttpInfo(String codeStructure, String codeApprenant, String codeCible, String codePiece) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = contenuPieceRequestBuilder(codeStructure, codeApprenant, codeCible, codePiece);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("contenuPiece", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<File>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<File>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<File>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder contenuPieceRequestBuilder(String codeStructure, String codeApprenant, String codeCible, String codePiece) throws ApiException {
    // verify the required parameter 'codeStructure' is set
    if (codeStructure == null) {
      throw new ApiException(400, "Missing the required parameter 'codeStructure' when calling contenuPiece");
    }
    // verify the required parameter 'codeApprenant' is set
    if (codeApprenant == null) {
      throw new ApiException(400, "Missing the required parameter 'codeApprenant' when calling contenuPiece");
    }
    // verify the required parameter 'codeCible' is set
    if (codeCible == null) {
      throw new ApiException(400, "Missing the required parameter 'codeCible' when calling contenuPiece");
    }
    // verify the required parameter 'codePiece' is set
    if (codePiece == null) {
      throw new ApiException(400, "Missing the required parameter 'codePiece' when calling contenuPiece");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/gestion/inscriptions/{codeStructure}/{codeApprenant}/{codeCible}/{codePiece}/contenu"
        .replace("{codeStructure}", ApiClient.urlEncode(codeStructure.toString()))
        .replace("{codeApprenant}", ApiClient.urlEncode(codeApprenant.toString()))
        .replace("{codeCible}", ApiClient.urlEncode(codeCible.toString()))
        .replace("{codePiece}", ApiClient.urlEncode(codePiece.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "image/png, image/jpg, application/pdf");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Récupérer le dossier complet d&#39;un apprenant
   * Récupérer le dossier complet d&#39;un apprenant 
   * @param codeStructure Le code de l&#39;établissement (required)
   * @param codeApprenant Le code de l&#39;apprenant (required)
   * @return ApprenantEtInscriptions
   * @throws ApiException if fails to make API call
   */
  public ApprenantEtInscriptions lireInscriptions(String codeStructure, String codeApprenant) throws ApiException {
    ApiResponse<ApprenantEtInscriptions> localVarResponse = lireInscriptionsWithHttpInfo(codeStructure, codeApprenant);
    return localVarResponse.getData();
  }

  /**
   * Récupérer le dossier complet d&#39;un apprenant
   * Récupérer le dossier complet d&#39;un apprenant 
   * @param codeStructure Le code de l&#39;établissement (required)
   * @param codeApprenant Le code de l&#39;apprenant (required)
   * @return ApiResponse&lt;ApprenantEtInscriptions&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ApprenantEtInscriptions> lireInscriptionsWithHttpInfo(String codeStructure, String codeApprenant) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = lireInscriptionsRequestBuilder(codeStructure, codeApprenant);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("lireInscriptions", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<ApprenantEtInscriptions>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<ApprenantEtInscriptions>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ApprenantEtInscriptions>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder lireInscriptionsRequestBuilder(String codeStructure, String codeApprenant) throws ApiException {
    // verify the required parameter 'codeStructure' is set
    if (codeStructure == null) {
      throw new ApiException(400, "Missing the required parameter 'codeStructure' when calling lireInscriptions");
    }
    // verify the required parameter 'codeApprenant' is set
    if (codeApprenant == null) {
      throw new ApiException(400, "Missing the required parameter 'codeApprenant' when calling lireInscriptions");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/gestion/inscription/{codeStructure}/{codeApprenant}/"
        .replace("{codeStructure}", ApiClient.urlEncode(codeStructure.toString()))
        .replace("{codeApprenant}", ApiClient.urlEncode(codeApprenant.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Chercher les données de la carte multi-services permettant également de répondre au besoin du flux des comptes
   * Les données renvoyées correspondent aux inscriptions validées, annulées ou ayant fait l&#39;objet d&#39;une actualisation
   * @param depuis L&#39;horodatage de la dernière extraction (exprimé en nombre de secondes depuis le 01/01/1970). Les entrées modifiées ou créées depuis seront remontées. (optional)
   * @param jusqua L&#39;horodatage à partir duquel les entrées sont exclues (exprimé en nombre de secondes depuis le 01/01/1970). Si absent ou 0, toutes les entrées seront remontées depuis l&#39;horodatage depuis. (optional, default to 0)
   * @param photo Inclure la photo d&#39;identité binaire dans les réponses. (optional, default to false)
   * @param codePeriode Code de la période (optional)
   * @param pageable L&#39;objet de pagination (page : le numéro de la page (défaut 0), taille : le nombre d&#39;élément par page (défaut 50)) (optional)
   * @param codeApprenant Code apprenant (optional)
   * @return VueInscriptions
   * @throws ApiException if fails to make API call
   */
  public VueInscriptions listerFluxInscriptionsPagine(Long depuis, Long jusqua, Boolean photo, String codePeriode, Pageable pageable, String codeApprenant) throws ApiException {
    ApiResponse<VueInscriptions> localVarResponse = listerFluxInscriptionsPagineWithHttpInfo(depuis, jusqua, photo, codePeriode, pageable, codeApprenant);
    return localVarResponse.getData();
  }

  /**
   * Chercher les données de la carte multi-services permettant également de répondre au besoin du flux des comptes
   * Les données renvoyées correspondent aux inscriptions validées, annulées ou ayant fait l&#39;objet d&#39;une actualisation
   * @param depuis L&#39;horodatage de la dernière extraction (exprimé en nombre de secondes depuis le 01/01/1970). Les entrées modifiées ou créées depuis seront remontées. (optional)
   * @param jusqua L&#39;horodatage à partir duquel les entrées sont exclues (exprimé en nombre de secondes depuis le 01/01/1970). Si absent ou 0, toutes les entrées seront remontées depuis l&#39;horodatage depuis. (optional, default to 0)
   * @param photo Inclure la photo d&#39;identité binaire dans les réponses. (optional, default to false)
   * @param codePeriode Code de la période (optional)
   * @param pageable L&#39;objet de pagination (page : le numéro de la page (défaut 0), taille : le nombre d&#39;élément par page (défaut 50)) (optional)
   * @param codeApprenant Code apprenant (optional)
   * @return ApiResponse&lt;VueInscriptions&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<VueInscriptions> listerFluxInscriptionsPagineWithHttpInfo(Long depuis, Long jusqua, Boolean photo, String codePeriode, Pageable pageable, String codeApprenant) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listerFluxInscriptionsPagineRequestBuilder(depuis, jusqua, photo, codePeriode, pageable, codeApprenant);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listerFluxInscriptionsPagine", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<VueInscriptions>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<VueInscriptions>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<VueInscriptions>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listerFluxInscriptionsPagineRequestBuilder(Long depuis, Long jusqua, Boolean photo, String codePeriode, Pageable pageable, String codeApprenant) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/gestion/flux-inscriptions/pagine";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "depuis";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("depuis", depuis));
    localVarQueryParameterBaseName = "jusqua";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("jusqua", jusqua));
    localVarQueryParameterBaseName = "photo";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("photo", photo));
    localVarQueryParameterBaseName = "codePeriode";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("codePeriode", codePeriode));
    localVarQueryParameterBaseName = "pageable";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("page", pageable.getPage()));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("taille", pageable.getTaille()));
    localVarQueryParameterBaseName = "codeApprenant";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("codeApprenant", codeApprenant));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
